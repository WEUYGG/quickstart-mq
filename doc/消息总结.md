异步解耦，削峰填谷

客户端：SDK方式提供jar，屏蔽不同消息中间件差异，修复完善功能、定制开发
Console：配置（动态生效）、监控告警、运维、租户



1、屏蔽不同消息中间件差异：发送、消费接口，队列负载均衡，主题队列模型，集群模型等
2、定制开发：消息压缩，消息加解密，消息轨迹跟踪、消息稽核、监控告警、消息去重、broker故障隔离、消息异常（生产、消费）的持久化、消息分析（业务端开发）
	权限、流控、黑白名单等
	熔断：broker积压之后熔断，消费端消费的mq积压之后，熔断退出由其他消费者消费
3、Console：监控、运维、配置



1、统一发送消费接口、对象，屏蔽差异
2、主题队列的负载均衡：主题的分片，发送负载路由（提升并发TPS）
3、集群模型的优化
4、消息序列化提供：(Kryo和FST)
5、消息压缩
6、消息加解密
7、消息轨迹跟踪（ES,Jest(searchbox)作为客户端查询）
8、消息稽核
9、消息的监控告警
10、消费端的去重（Redis，setnx命令）
11、broker故障隔离
12、消息异常（生产、消费）的持久化
13、消息分析（业务端开发）
14、权限、黑白名单等
15、消费端消费的mq积压之后，熔断退出由其他消费者消费
16、连接池的使用：对象、连接统一管控，动态调整（线程池）
17、配置的动态刷新（console、amber、local）

同步、异步发送回调、顺序、事务、事务的统一提交
发送客户端的限流（TTL动态批量统计）
消息对象使用对象池的技术



消息类型：
从通讯方式：
同步、异步、oneway


顺序消息
事务消息
延时消息（定时消息）
tag消息
消息优先级



消息选型比较：
功能性、TPS、积压、
社区、文档、语言、持久化、事务、负载均衡、扩缩容、部署、维护



Activemq和Rocketmq：
实现的协议：
存储消息的方式和处理：
生产端和消费端



遇到问题：
1、mq版本5.13.2，是3台mq配合zookeeper组成的集群
出现异常之前手动停止了mq集群，停止的时候有生产者在生产消息
启动集群后，有脏数据的mq的leveldb就同步到了整个集群，导致一只出现主从切换，只能删除所有leveldb才能恢复

1、Rocketmq的队列大小扩缩容：缩容时候，导致部分数据无法消费
2、consumer设置上instanceName后，无法集群消费的问题调查：以为是因为设置的广播消费模式，发现不是，原来是如果设置上这个参数，启动多个jvm进程，则currentCID都一样，而计算rebalance时如下代码导致每次将所有的queue分配到一个consumer上：
int index = cidAll.indexOf(currentCID);
3、Rocketmq的发送消息，同步发送，设置同步刷盘，但是刷盘要保存的commitlog被删除，也会返回成功。




